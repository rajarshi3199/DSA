from sortedcontainers import SortedList

class Solution:
    def minimumCost(self, nums: list[int], k: int, dist: int) -> int:
        n = len(nums)
        # We need to pick nums[0] and then k-1 more elements from a window
        # The window size is dist + 1
        # Let i1 be the first picked index. The last index ik-1 <= i1 + dist.
        # This means all k-1 elements must be within a range of length dist + 1.
        
        target_count = k - 1
        window_size = dist + 1
        
        # left maintains the smallest target_count elements
        left = SortedList()
        # right maintains the remaining elements in the window
        right = SortedList()
        
        current_left_sum = 0
        
        def add(val):
            nonlocal current_left_sum
            left.add(val)
            current_left_sum += val
            if len(left) > target_count:
                removed = left.pop()
                current_left_sum -= removed
                right.add(removed)
                
        def remove(val):
            nonlocal current_left_sum
            if val in left:
                left.remove(val)
                current_left_sum -= val
                if right:
                    promoted = right.pop(0)
                    left.add(promoted)
                    current_left_sum += promoted
            else:
                right.remove(val)

        # Initialize the first window (indices 1 to dist + 1)
        for i in range(1, window_size + 1):
            add(nums[i])
            
        min_total_cost = nums[0] + current_left_sum
        
        # Slide the window across the array
        for i in range(2, n - dist):
            # i is the new potential i1. The window is [i, i + dist]
            # Remove the element that is no longer reachable (nums[i-1])
            # Add the new element that just entered the range (nums[i + dist])
            remove(nums[i-1])
            add(nums[i + dist])
            
            min_total_cost = min(min_total_cost, nums[0] + current_left_sum)
            
        return min_total_cost
